'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _getNested = require('get-nested');

var _getNested2 = _interopRequireDefault(_getNested);

var _site = require('../utils/site');

var _site2 = _interopRequireDefault(_site);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
    return new (P || (P = _promise2.default))(function (resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : new P(function (resolve) {
                resolve(result.value);
            }).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};

var EntityMapper = function (_Component) {
    (0, _inherits3.default)(EntityMapper, _Component);

    function EntityMapper(props) {
        (0, _classCallCheck3.default)(this, EntityMapper);

        var _this = (0, _possibleConstructorReturn3.default)(this, (EntityMapper.__proto__ || (0, _getPrototypeOf2.default)(EntityMapper)).call(this, props));

        _this.state = {
            entityProps: props.entityProps,
            mapper: EntityMapper.getMapperFromProps(props),
            ready: false,
            uuid: props.uuid
        };
        return _this;
    }
    /**
     * This makes sure the data for this url is ready to be rendered.
     * @param uuid
     * @param mapper
     * @param asyncMapper
     * @returns void
     */


    (0, _createClass3.default)(EntityMapper, [{
        key: 'asyncBootstrap',

        /**
         * If this component exists in a tree that is invoked with the waitForHnData function, this function is invoked.
         * Only after the promise is resolved, the component will be mounted. To keep the data fetched here, we assign the
         * state to the hnContext provided by the DrupalPageContextProvider. This way, the state will be preserved trough
         * multiple renders.
         */
        value: function asyncBootstrap() {
            return __awaiter(this, void 0, void 0, /*#__PURE__*/_regenerator2.default.mark(function _callee() {
                var _this2 = this;

                var asyncMapper, _state, uuid, entityProps, mapper, state;

                return _regenerator2.default.wrap(function _callee$(_context) {
                    while (1) {
                        switch (_context.prev = _context.next) {
                            case 0:
                                asyncMapper = this.props.asyncMapper;
                                _state = this.state, uuid = _state.uuid, entityProps = _state.entityProps, mapper = _state.mapper;
                                // If this mapper + uuid combination is already in state, use that state

                                state = (0, _getNested2.default)(function () {
                                    return _this2.context.hnContext.state.entities.find(function (e) {
                                        return e.mapper === mapper && e.uuid === uuid;
                                    }).componentState;
                                });

                                if (!state) {
                                    _context.next = 5;
                                    break;
                                }

                                return _context.abrupt('return', true);

                            case 5:
                                _context.t0 = this.context.hnContext.state.entities;
                                _context.next = 8;
                                return this.loadComponent({
                                    asyncMapper: asyncMapper,
                                    entityProps: entityProps,
                                    mapper: mapper,
                                    uuid: uuid
                                });

                            case 8:
                                _context.t1 = _context.sent;
                                _context.t2 = mapper;
                                _context.t3 = uuid;
                                _context.t4 = {
                                    componentState: _context.t1,
                                    mapper: _context.t2,
                                    uuid: _context.t3
                                };

                                _context.t0.push.call(_context.t0, _context.t4);

                                return _context.abrupt('return', true);

                            case 14:
                            case 'end':
                                return _context.stop();
                        }
                    }
                }, _callee, this);
            }));
        }
        /**
         * The first time this element is rendered, we always make sure the component and the Drupal page is loaded.
         */

    }, {
        key: 'componentWillMount',
        value: function componentWillMount() {
            var _this3 = this;

            var uuid = this.props.uuid;
            var mapper = this.state.mapper;

            var state = (0, _getNested2.default)(function () {
                return _this3.context.hnContext.state.entities.find(function (e) {
                    return e.mapper === mapper && e.uuid === uuid;
                }).componentState;
            });
            if (state) {
                this.setState(state);
            } else {
                this.loadComponent((0, _assign2.default)({}, this.props, { mapper: EntityMapper.getMapperFromProps(this.props) }));
            }
        }
    }, {
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(nextProps) {
            if (this.props.uuid !== nextProps.uuid || this.props.mapper !== nextProps.mapper || this.props.asyncMapper !== nextProps.asyncMapper) {
                this.loadComponent((0, _assign2.default)({}, nextProps, { mapper: EntityMapper.getMapperFromProps(nextProps) }));
            }
        }
    }, {
        key: 'loadComponent',
        value: function loadComponent(_ref) {
            var uuid = _ref.uuid,
                mapper = _ref.mapper,
                asyncMapper = _ref.asyncMapper,
                entityProps = _ref.entityProps;

            return __awaiter(this, void 0, void 0, /*#__PURE__*/_regenerator2.default.mark(function _callee2() {
                var entityComponent, newState;
                return _regenerator2.default.wrap(function _callee2$(_context2) {
                    while (1) {
                        switch (_context2.prev = _context2.next) {
                            case 0:
                                // Check if component for combination of mapper + uuid already was loaded
                                entityComponent = EntityMapper.entityComponents.find(function (c) {
                                    return c.mapper === mapper && c.uuid === uuid;
                                });
                                // If component isn't loaded yet, go load it

                                if (entityComponent) {
                                    _context2.next = 5;
                                    break;
                                }

                                this.setState({ ready: false });
                                _context2.next = 5;
                                return EntityMapper.assureComponent({
                                    asyncMapper: asyncMapper,
                                    mapper: mapper,
                                    uuid: uuid
                                });

                            case 5:
                                newState = (0, _assign2.default)({}, this.state, { entityProps: entityProps,
                                    mapper: mapper, ready: true, uuid: uuid });

                                this.setState(newState);
                                return _context2.abrupt('return', newState);

                            case 8:
                            case 'end':
                                return _context2.stop();
                        }
                    }
                }, _callee2, this);
            }));
        }
    }, {
        key: 'isReady',
        value: function isReady() {
            return this.state.ready;
        }
    }, {
        key: 'render',
        value: function render() {
            var _state2 = this.state,
                uuid = _state2.uuid,
                entityProps = _state2.entityProps,
                mapper = _state2.mapper;

            var entity = _site2.default.getData(uuid);
            if (!entity) {
                return null;
            }
            var EntityComponent = (0, _getNested2.default)(function () {
                return EntityMapper.entityComponents.find(function (c) {
                    return c.uuid === uuid && c.mapper === mapper;
                }).component;
            });
            if (!EntityComponent) {
                return null;
            }
            return _react2.default.createElement(EntityComponent, (0, _assign2.default)({ bundle: EntityMapper.getBundle(entity), paragraph: entity, entity: entity }, entityProps));
        }
    }], [{
        key: 'assureComponent',
        value: function assureComponent(_ref2) {
            var uuid = _ref2.uuid,
                mapper = _ref2.mapper,
                asyncMapper = _ref2.asyncMapper;

            return __awaiter(this, void 0, void 0, /*#__PURE__*/_regenerator2.default.mark(function _callee3() {
                var entity, bundle, entityComponent;
                return _regenerator2.default.wrap(function _callee3$(_context3) {
                    while (1) {
                        switch (_context3.prev = _context3.next) {
                            case 0:
                                // This gets the entity from the site, based on the uuid.
                                entity = _site2.default.getData(uuid);
                                // This should give back a bundle string, that is used in the mapper.

                                bundle = EntityMapper.getBundle(entity);
                                // Get the component that belongs to this entity type

                                entityComponent = typeof mapper === 'function' ? mapper(entity, bundle) : mapper[bundle];
                                // If asyncMapper is true, execute the function so it returns a promise.

                                if (asyncMapper && typeof entityComponent === 'function') {
                                    entityComponent = entityComponent();
                                }
                                // If a promise was returned, resolve it.

                                if (!(entityComponent && typeof entityComponent.then !== 'undefined')) {
                                    _context3.next = 8;
                                    break;
                                }

                                _context3.next = 7;
                                return entityComponent;

                            case 7:
                                entityComponent = _context3.sent;

                            case 8:
                                if (entityComponent) {
                                    _context3.next = 10;
                                    break;
                                }

                                return _context3.abrupt('return');

                            case 10:
                                // If it has a .default (ES6+), use that.
                                if (entityComponent.default) {
                                    entityComponent = entityComponent.default;
                                }
                                // Store the entityComponent globally, so it can be rendered sync.
                                EntityMapper.entityComponents.push({
                                    component: entityComponent,
                                    mapper: mapper,
                                    uuid: uuid
                                });

                            case 12:
                            case 'end':
                                return _context3.stop();
                        }
                    }
                }, _callee3, this);
            }));
        }
    }]);
    return EntityMapper;
}(_react.Component);

EntityMapper.entityComponents = [];
EntityMapper.contextTypes = {
    hnContext: _propTypes2.default.object
};
EntityMapper.getBundle = function (entity) {
    return (0, _getNested2.default)(function () {
        return entity.__hn.entity.type + '__' + entity.__hn.entity.bundle;
    }, '_fallback');
};
/**
 * Use this method to get a final mapper, based on both the asyncMapper & mapper prop.
 * This ensures backwards compatibility.
 * @param asyncMapper
 * @param mapper
 * @returns {*} mapper
 */
EntityMapper.getMapperFromProps = function (_ref3) {
    var asyncMapper = _ref3.asyncMapper,
        mapper = _ref3.mapper;
    return typeof asyncMapper === 'boolean' ? mapper : asyncMapper;
};
EntityMapper.propTypes = {
    asyncMapper: _propTypes2.default.oneOfType([_propTypes2.default.bool, _propTypes2.default.oneOfType([_propTypes2.default.shape(), _propTypes2.default.func])]),
    entityProps: _propTypes2.default.shape(),
    mapper: _propTypes2.default.oneOfType([_propTypes2.default.shape(), _propTypes2.default.func, _propTypes2.default.bool]),
    uuid: _propTypes2.default.string.isRequired
};
EntityMapper.defaultProps = {
    asyncMapper: false,
    entityProps: {},
    mapper: false
};
exports.default = EntityMapper;
//# sourceMappingURL=EntityMapper.js.map
