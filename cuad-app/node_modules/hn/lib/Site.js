"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var es6_promise_1 = require("es6-promise");
require("isomorphic-fetch");
var deepmerge = require("deepmerge");
var getNested = require("get-nested");
var query_string_1 = require("query-string");
es6_promise_1.polyfill();
var propertiesToHydrate = ['tokensToVerify', 'user', 'data'];
var Site = (function () {
    function Site(initParams) {
        this.reset();
        if (initParams)
            this.initialize(initParams);
    }
    Site.prototype.initialize = function (_a) {
        var url = _a.url, _b = _a.fetchOptions, fetchOptions = _b === void 0 ? {} : _b;
        if (this.initialized)
            throw Error('The site is already initialized.');
        this.initialized = true;
        this.url = url;
        this.fetchOptions = fetchOptions;
    };
    Site.prototype.reset = function () {
        this.initialized = false;
        this.url = null;
        this.tokensToVerify = [];
        this.user = null;
        this.data = {
            data: {},
            paths: {},
        };
        this.pagesLoading = {};
    };
    /**
     * Creates an object that can be hydrated by the hydrate function.
     */
    Site.prototype.dehydrate = function () {
        var _this = this;
        var dehydrated = {};
        propertiesToHydrate.forEach(function (property) {
            dehydrated[property] = _this[property];
        });
        return dehydrated;
    };
    /**
     * Updates all properties with the object created by the dehydrate function.
     */
    Site.prototype.hydrate = function (options) {
        var _this = this;
        propertiesToHydrate.forEach(function (property) {
            _this[property] = options[property];
        });
    };
    Site.prototype.fetch = function (path, options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        if (!this.initialized) {
            throw Error('Site is not intitialized. Pass an object when creating a site, or use the ' +
                'initialize method.');
        }
        return fetch(this.url + path, __assign({ method: 'GET', mode: 'cors', cache: 'default' }, options, this.fetchOptions))
            .then(function (response) {
            if (!response.ok) {
                throw Error("Error at path: " + (_this.url + path) + ": " + response.status + " - " + response.statusText);
            }
            return response.json();
        });
    };
    Site.prototype.getPage = function (path, loadFromServer) {
        var _this = this;
        if (loadFromServer === void 0) { loadFromServer = false; }
        if (!this.pagesLoading[path]) {
            var dataMaybeAlreadyLoaded_1 = getNested(function () { return _this.data.data[_this.data.paths[path]]; });
            if (getNested(function () { return dataMaybeAlreadyLoaded_1.__hn.view_modes.includes('default'); })) {
                this.pagesLoading[path] = es6_promise_1.Promise.resolve(this.data.paths[path]);
            }
        }
        if (loadFromServer === true || !this.pagesLoading[path]) {
            // Copy this.tokensToVerify for this single request.
            var tokensToVerify_1 = this.tokensToVerify.slice();
            this.pagesLoading[path] = this.fetch('/hn?' + query_string_1.stringify({
                path: path,
                _format: 'hn',
                _hn_user: this.user ? this.user : undefined,
                _hn_verify: tokensToVerify_1,
            }))
                .then(function (page) {
                // Get the user id, to pass to all new requests.
                _this.user = getNested(function () { return page.__hn.request.user; }, _this.user);
                // Remove all sent tokens from the tokensToVerify.
                _this.tokensToVerify = _this.tokensToVerify.filter(function (t) { return tokensToVerify_1.indexOf(t) === -1; });
                // Add new token to tokensToVerify.
                var newToken = getNested(function () { return page.__hn.request.token; });
                if (newToken)
                    _this.tokensToVerify.push(newToken);
                // Add all data to the global data storage.
                _this.addData(page);
            })
                .catch(function (error) {
                console.error(error);
                _this.addData({
                    paths: (_a = {},
                        _a[path] = '500',
                        _a),
                });
                var _a;
            })
                .then(function () { return _this.data.paths[path]; });
        }
        return this.pagesLoading[path];
    };
    Site.prototype.addData = function (data) {
        this.data = deepmerge(this.data, data, { arrayMerge: function (a, b) { return b; } });
    };
    Site.prototype.getData = function (key) {
        return this.data.data[key];
    };
    /**
     * * Translate ninja
     * Get the translations from the settings block.
     * Gets the language from context, or from parameter if overruled.
     * Returns input string when no translations are available.
     * @param string
     * @param langCode
     * @return {*}
     */
    // tslint:disable-next-line function-name
    Site.prototype.t = function (string, langCode) {
        var _this = this;
        var settings = this.getData('settings');
        var path = this.data.paths[window.location.pathname];
        var lang = langCode || getNested(function () { return _this.getData(path).langcode; }, 'en');
        return getNested(function () { return settings.translations[string][lang]; }, string);
    };
    return Site;
}());
exports.default = Site;
//# sourceMappingURL=Site.js.map